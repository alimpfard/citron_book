<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Citron Book</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><a href="chapter1.html"><strong aria-hidden="true">2.</strong> Dedication</a></li><li><a href="preface.html"><strong aria-hidden="true">3.</strong> Preface</a></li><li><a href="about-citron.html"><strong aria-hidden="true">4.</strong> About Citron</a></li><li><a href="installation.html"><strong aria-hidden="true">5.</strong> Installation</a></li><li><a href="baby-steps.html"><strong aria-hidden="true">6.</strong> Baby Steps!</a></li><li><a href="basics.html"><strong aria-hidden="true">7.</strong> Basics</a></li><li><a href="expressions-and-messages.html"><strong aria-hidden="true">8.</strong> Expressions and Messages</a></li><li><a href="control-flow.html"><strong aria-hidden="true">9.</strong> Control Flow</a></li><li><a href="functions.html"><strong aria-hidden="true">10.</strong> Functions</a></li><li><a href="intermission-interpreter-commands.html"><strong aria-hidden="true">11.</strong> Intermission: Interpreter Commands</a></li><li><a href="data-structures.html"><strong aria-hidden="true">12.</strong> Data Structures</a></li><li><a href="objects.html"><strong aria-hidden="true">13.</strong> Objects</a></li><li><a href="io.html"><strong aria-hidden="true">14.</strong> IO</a></li><li><a href="exceptions.html"><strong aria-hidden="true">15.</strong> Exceptions</a></li><li><a href="libraryimports.html"><strong aria-hidden="true">16.</strong> Library/Imports</a></li><li><a href="standard-library.html"><strong aria-hidden="true">17.</strong> Standard Library</a></li><li><a href="parse-time-meta-functions.html"><strong aria-hidden="true">18.</strong> Meta-functions</a></li><li><a href="parser-pragmas.html"><strong aria-hidden="true">19.</strong> Parser Pragmas</a></li><li><a href="scratchpad.html"><strong aria-hidden="true">20.</strong> Scratchpad</a></li><li><a href="inline-assembly-blocks.html"><strong aria-hidden="true">21.</strong> Inline Assembly Blocks</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Citron Book</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#project-citron----a-totally-not-definitive-guide" id="project-citron----a-totally-not-definitive-guide">Project Citron -- A totally-not-definitive Guide</a></h1>
<p>This is an <em>obviously</em> free book detailing the use of the Citron language; It serves as a tutorial for intermediate audience.</p>
<p>This text assumes a basic knowledge about common programming terms and concepts.</p>
<h2><a class="header" href="#start-a-hrefsummaryhtmlherea" id="start-a-hrefsummaryhtmlherea">Start <a href="SUMMARY.html">Here</a></a></h2>
<h1><a class="header" href="#dedication" id="dedication">Dedication</a></h1>
<p>To myself.</p>
<p><em>what, did you expect anything interesting</em>?</p>
<h1><a class="header" href="#preface" id="preface">Preface</a></h1>
<p>TODO</p>
<h1><a class="header" href="#about-citron" id="about-citron">About Citron</a></h1>
<p>Citron is a language that tries to explore the ideas and combine things that have barely ever been combined.</p>
<p>It is by no means meant to be used for serious projects and is <em>as of yet</em> in a beta stage.</p>
<h1><a class="header" href="#installation" id="installation">Installation</a></h1>
<p>Citron is meant to be used on UNIX-like systems, and as such it does not, and <em>will not</em> support Window.</p>
<h2><a class="header" href="#binaries" id="binaries">Binaries</a></h2>
<p>Basic binary builds are provided for Linux (ELF x86_64) and Windows (PE x86_64)<br />
You can get them from <a href="https://github.com/alimpfard/citron/releases">the repository releases</a></p>
<h2><a class="header" href="#building-from-source" id="building-from-source">Building From Source</a></h2>
<p>Clone the git repository at <a href="https://github.com/alimpfard/citron">https://github.com/alimpfard/citron</a>.</p>
<p>To make a debug build in the main directory:</p>
<pre><code>$ cd citron
$ make debug
</code></pre>
<p>or alternatively to make and install citron to the system:</p>
<pre><code>$ cd citron/autohell
$ aclocal &amp;&amp; autoconf &amp;&amp; automake --add-missing &amp;&amp; libtoolize
$ make &amp;&amp; sudo make install
</code></pre>
<p>which will install the <code>ctr</code> executable, an interactive interpreter <code>citron</code> and the library and headers.</p>
<h2><a class="header" href="#summary" id="summary">Summary</a></h2>
<p>We will now assume you have Citron installed on your system.</p>
<p>Give it a go with launching the interpreter <code>citron</code></p>
<h2><a class="header" href="#warning-about-copypasting-code-into-the-evaluator" id="warning-about-copypasting-code-into-the-evaluator">Warning about copy/pasting code into the evaluator</a></h2>
<p>Remember to put it in paste mode (press F2) before pasting</p>
<p>Exiting paste mode is just like entering it (F2)</p>
<h1><a class="header" href="#baby-steps" id="baby-steps">Baby Steps</a></h1>
<p>Clearly, every language requires a 'Hello, World!' program.</p>
<p>There are mainly three ways of executing citron code:</p>
<ul>
<li>with the main executable <code>ctr</code></li>
<li>with the scratchpad (neat thing, tbh) (see <a href="/scratchpad.html">Scratchpad</a>\)</li>
<li>with the (JIT) interpreter</li>
<li>compiling it with <code>ctrc</code> and executing that [this only generates a simple program that links into the Citron runtime, it is not static]</li>
</ul>
<h3><a class="header" href="#using-the-interpreter-prompt" id="using-the-interpreter-prompt">Using the Interpreter Prompt</a></h3>
<p>Presumably, you have a terminal window open from back when you compiled citron from source, so switch to it,</p>
<p>and start the interpreter by executing <code>citron</code> and pressing <code>&lt;return&gt;</code></p>
<p>Once you have started the interpreter, it will greet you with a nice-looking ascii art,</p>
<p>and the main prompt (default <code>⠕</code> )</p>
<p>Type <code>Pen writeln: 'Hello, World!'</code> followed by the return key.</p>
<p>You shall see the magical words <code>Hello, World!</code> printed to the screen. (and a <code>[_:Object]</code> which signifies the object <code>Pen</code>; in general, Objects without the method toString are shown in this format: <code>[&lt;name in current context&gt;:Type]</code>)</p>
<p>Here's an example of what you might expect to see:</p>
<pre><code>$ citron
Terminal: 24x83 - 0x0
  _____ _ _
 / ____(_) |
| |     _| |_ _ __ ___  _ __
| |    | | __| '__/ _ \| '_ \  Project Citron
| |____| | |_| | | (_) | | | |
 \_____|_|\__|_|  \___/|_| |_|

0.0.8.8-boehm-gc [GCC/G++ 8.2.0]
⠕ Pen writeln: 'Hello, World!'
Hello, World!
[_:Object]
</code></pre>
<h4><a class="header" href="#how-do-i-quit-this-interpreter" id="how-do-i-quit-this-interpreter">How do I quit this interpreter?</a></h4>
<p>Type <code>:q</code> and press return.</p>
<p>Or just press Ctrl + D.</p>
<p>or if you really like punching in expressions, evaluate <code>Eval end</code></p>
<h3><a class="header" href="#choosing-an-editor" id="choosing-an-editor">Choosing an editor</a></h3>
<p>Currently, Atom, TextMate and Sublime 3 syntax files are generated and maintained.<br />
However, minimal Smalltalk syntax highlighting will do in a pinch</p>
<h3><a class="header" href="#using-a-source-file" id="using-a-source-file">Using a source file</a></h3>
<p>Back to coding.</p>
<p>Open a new file [I have used <code>main.ctr</code> for most of the files] (generic extension is <code>.ctr</code>) and type this in:</p>
<pre><code class="language-ruby">Pen writeln: 'Hello, World!'.
</code></pre>
<p>Then simply run <code>ctr</code> with the sole argument being the path to the file.</p>
<pre><code>$ ctr main.ctr
Hello, World!
</code></pre>
<h2><a class="header" href="#basics" id="basics">Basics</a></h2>
<p>Printing <code>Hello, World!</code> is always exciting and all, but it's never enough...maybe some inputs, processing, and some actually useful output is always preferred!</p>
<h3><a class="header" href="#comments" id="comments">Comments</a></h3>
<p><em>Comments</em> always span a signle line, beginning with the character <code>#</code></p>
<p>(Do note that the interactive interpreter will not allow comments)<br />
For example:</p>
<pre><code class="language-ruby">Pen writeln: 'Hello, World'. #Totally ignore me, okay?
</code></pre>
<p>or:</p>
<pre><code class="language-ruby">#Pen is an Object, and 'writeln:' is a message
Pen writeln: 'HELLO!'.
</code></pre>
<p>Some people like comments, so make sure to use them lots, okay?</p>
<h3><a class="header" href="#literals" id="literals">Literals</a></h3>
<p>An example of a literal is a number, like <code>5</code>, <code>3.14</code>, <code>0xAF</code> or a string <code>'Hello'</code>.</p>
<h4><a class="header" href="#numbers" id="numbers">Numbers</a></h4>
<p>The only numeric type available to the programmer is <code>Number</code>, which can store up to a 64-bit double's worth.</p>
<p>(<code>BigInteger</code> is available for arbitrary precision Integer numeric values as well)</p>
<h3><a class="header" href="#strings" id="strings">Strings</a></h3>
<p>String literals are created in two ways:</p>
<ul>
<li>Strings with processed escape codes -- which are enclosed in single quotes: <code>'Hello, world!\n</code>'</li>
<li>'Raw' Strings, which are quoted literally (mainly used for regular expressions, or embedding other languages), enclosed in <code>?&gt;</code> and <code>&lt;?</code> : <code>?&gt;\s\t\w&lt;?</code></li>
</ul>
<p>Both of these can span multiple lines.</p>
<h4><a class="header" href="#string-formatting" id="string-formatting">String formatting</a></h4>
<p>clearly everyone needs string formatting</p>
<p>Two solutions are provided:</p>
<ul>
<li>
<p>Embedding a variable inside the string: <code>Hello, $$name !'</code></p>
</li>
<li>
<p>Using the format methods: <code>'Hello, %s!' % [name]</code></p>
</li>
<li>
<p>or the other format method: <code>'Hello, %{name}' %~: (Map fromArray: [['name', 'What']]</code></p>
</li>
</ul>
<p>The first solution is used as a quick-and-dirty way to embed single variables inside a string, and are processed by the lexer to a string addition expression: <code>'Hello, ' + name + ' !'</code></p>
<p>The second one uses a method of the String object, <code>%</code> which provides printf-like string formatting</p>
<pre><code class="language-ruby">var age is 21.
var name is 'Semicolon'.

# Note that this $$var is not very versatile, it will only break on whitespace and such
Pen writeln: 'Hello, $$name you seem to have an age of $$age'.
Pen writeln: 'Hello, %s you seem to have an age of %d' % [name, age].
</code></pre>
<h4><a class="header" href="#escape-sequences" id="escape-sequences">Escape sequences</a></h4>
<p>The normal, basic sequences are supported.</p>
<p>Also a way of embedding characters as hexadecimal is provided: <code>\x12 or \x{12}</code></p>
<p>which will consume all the hexadecimal digits it can.</p>
<p>As well as unicode characters: <code>\u2002 or \u{2002}</code></p>
<h3><a class="header" href="#tuples" id="tuples">Tuples</a></h3>
<p>Contrary to what you might be used to, Citron's tuples are generated at <em>parse time</em> and have a (pretty much) immutable structure</p>
<p>They are created like so:</p>
<pre><code class="language-ruby">[element0, element1] # A tuple with two elements. you can treat this like an Array object
[] # An empty tuple
</code></pre>
<h4><a class="header" href="#code-blocks" id="code-blocks">Code Blocks</a></h4>
<p>A code block is just like a normal function, except the fact that it is <em>anonymous</em>.</p>
<p>It may or may not be a closure.</p>
<p>There are two main code block types:</p>
<ul>
<li>Basic code block -- which is always executed whenever it is required to. <code>{ (:param)* (expression.)* }</code></li>
<li>Lexically scoped code block -- which always captures every value that is not in its formal parameters. <code>{\ (:param)* (expression.)* }</code></li>
</ul>
<p>To return from a block, the return token <code>^</code> is used.</p>
<p>A shorthand for a lexical code block with a single expression and at least one parameter (quite like a lambda) exists: <code>(:param)+ expression</code></p>
<p>which is translated to <code>{\(:param)+ ^expression.}</code> by the parser.</p>
<h4><a class="header" href="#object" id="object">Object</a></h4>
<p>Anything and everything is an Object in Citron. <em>No Exceptions</em></p>
<p>(This does not mean that Citron <em>enforces</em> the idea of Object-Oriented Programming, but that is the most simple way of using the language)</p>
<h3><a class="header" href="#code-lines--semantics" id="code-lines--semantics">Code Lines &amp; Semantics</a></h3>
<p>All the statements <em>must</em> end in a dot (<code>.</code>)</p>
<p>You may put all the statements in a single line (why would you want to?)</p>
<p>Whitespace is ignored, and has virtually no meaning.</p>
<h3><a class="header" href="#assignment" id="assignment">Assignment</a></h3>
<p>There are three main forms of assignment in Citron, all of which have the general from <code>expr (:= | is) expr</code></p>
<ol>
<li>assignment to an existing reference: <code>name is value</code></li>
<li>creation and assignment to a new reference: <code>(var | my) name is value</code></li>
<li>assignment by deconstruction: <code>type_var is value</code>, which we will get back to in another chapter.</li>
</ol>
<p>Every reference can optionally have three (four) different modifiers (Only one can be active at any given time):</p>
<ol>
<li><code>var</code> : simply creates a new reference if no old ones exist, otherwise binds to them</li>
<li><code>my</code>   : creates or binds to a property of the current object.</li>
<li><code>const</code> : tries to capture a variable from the environment around the currrent object</li>
<li><code>frozen</code>: if the XFrozen pragma is active. expression is only evaluated once.</li>
</ol>
<p>There is a shorthand for assignment to an object property (<code>my property is value</code>): <code>property =&gt; value</code></p>
<p>which will prove useful in certain points (which we will explore in later chapters).</p>
<h2><a class="header" href="#expressions-and-messages" id="expressions-and-messages">Expressions and Messages</a></h2>
<p>All the statements will contain one, or more expressions.</p>
<p>There are <em>no</em> native operators, and all expressions are either mentions of an object, or messages sent to them.</p>
<h2><a class="header" href="#messages" id="messages">Messages</a></h2>
<p>There are three different semantics for messages</p>
<ul>
<li>
<p>Unary Messages -- These are <em>more</em> than one unicode code point long, and take no parameters, and have no colon after them.</p>
</li>
<li>
<p>Binary Messages -- These are either exactly one unicode code point long, or are equal to<code>::</code> , or are composed of any of <code>=+-*&amp;%$@~&lt;&gt;?;</code>. these take a single argument.</p>
</li>
<li>
<p>Keyword Messages -- These are arbitrarily long names, separated by colons</p>
</li>
</ul>
<p>Examples for each follow:</p>
<ul>
<li>Unary: <code>2 sin</code> or <code>2 toString</code> or <code>'test' reverse</code></li>
<li>Binary: <code>2 + 3</code> or <code>True | False</code> or <code>'te%st' % ['s']</code></li>
<li>Keyword: <code>2 between: 0 and: 3</code> or <code>True either: blk0 or: blk1</code> or <code>Array join: ', '</code></li>
</ul>
<h3><a class="header" href="#basic-messages-for-the-number-objects" id="basic-messages-for-the-number-objects">Basic messages for the Number objects</a></h3>
<ul>
<li>
<p>Binary <code>+</code></p>
<ul>
<li>Adds something to a number
<ul>
<li>Normally operates on Strings and Numbers</li>
</ul>
</li>
<li><code>3 + 5</code> gives <code>8</code>. <code>3 + 'test'</code> gives <code>'3test'</code>
<ul>
<li>Note that in no possible scenario a string would be implicitly cast to a number.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Binary <code>-</code></p>
<ul>
<li>Subtracts a number from another</li>
<li><code>10 - 8</code> gives <code>2</code></li>
</ul>
</li>
<li>
<p>Binary <code>*</code></p>
<ul>
<li>Multiplies a number by another</li>
<li><code>2 * 3</code> gives <code>6</code></li>
</ul>
</li>
<li>
<p>Keyword <code>pow:</code></p>
<ul>
<li>raises a number to a numeric power</li>
<li><code>2 pow: 3</code> gives <code>8</code></li>
</ul>
</li>
</ul>
<p>Tip:<br />
To see all the Number methods, type <code>:!m Number</code> in the interactive interpreter</p>
<h3><a class="header" href="#comparing-two-numbers" id="comparing-two-numbers">Comparing two numbers</a></h3>
<p>The method names are <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=:</code>, <code>&lt;=:</code>, <code>=</code>, <code>!=:</code></p>
<p>equality <em>can</em> be tested with the alias method <code>equals:</code>, However, when overriding equality, only <code>=</code> must be overridden.</p>
<h3><a class="header" href="#shortcuts-for-number-manipulations" id="shortcuts-for-number-manipulations">Shortcuts for number manipulations</a></h3>
<p>The methods <code>+=:</code>, <code>*=:</code>, <code>-=:</code>, <code>/=:</code> exist, but they change the object itself, so any instance of that object will have a different value.</p>
<pre><code class="language-ruby">var a is 123.
var b is a.

a -=: 3.

Pen writeln: b. #Prints 120
</code></pre>
<h3><a class="header" href="#evaluation-order" id="evaluation-order">Evaluation Order</a></h3>
<p>The generic order of evaluation is</p>
<ol>
<li>The receiver</li>
<li>The first argument (if present)</li>
<li>The second argument (if present)</li>
<li>and so on</li>
</ol>
<p>Parens are treated normally.</p>
<h2><a class="header" href="#control-flow" id="control-flow">Control Flow</a></h2>
<p>There are pretty much <em>no</em> keywords in citron, thus all control flow operations are carried out by interfacing the <code>Boolean</code> Object type.</p>
<h3><a class="header" href="#the-equivalent-to-a-if-else-structure" id="the-equivalent-to-a-if-else-structure">The equivalent to a if-else structure</a></h3>
<p>The method is <code>Boolean::'either:or:'</code>, alternatively, when one of the two branches is not needed, you may use <code>Boolean::'ifTrue:'</code> or <code>Boolean::'ifFalse:'</code></p>
<p>All of these take a block of code (in a basic form, code contained in <code>{</code> and <code>}</code>), and execute it if their condition is matched.</p>
<h5><a class="header" href="#an-example" id="an-example">An example</a></h5>
<pre><code class="language-ruby">var a is 123.
a &gt; 5 either: { 
    Pen writeln: '$$a is a big number!'. 
} or: { 
    Pen writeln: '$$a is a cute little number!'. 
}.
</code></pre>
<p>Should you return a value from the <code>either:or:</code> blocks, the whole expression will evaluate to that value.</p>
<p>However, remember that returning from <code>ifTrue:</code> or <code>ifFalse:</code> will return <strong>two</strong> leves instead of one.</p>
<h3><a class="header" href="#loops" id="loops">Loops</a></h3>
<p>Again, no keywords, so looping is achieved through interfacing Number (a for loop), or a block (a while loop).</p>
<h4><a class="header" href="#repeating-an-expression" id="repeating-an-expression">Repeating an expression</a></h4>
<p><code>Number::'times:'</code> to the rescue!</p>
<p>That method will run the given block with the iteration index.</p>
<pre><code class="language-ruby">10 times: {:value
    Pen writeln: value.
}.
</code></pre>
<h4><a class="header" href="#looping-over-a-range" id="looping-over-a-range">Looping over a range</a></h4>
<p><code>Number::'to:step:do:'</code> is a basic way of looping over a range.</p>
<pre><code class="language-ruby">5 to: 50 step: 5 do: {:value
    Pen writeln: value.
}.
</code></pre>
<h4><a class="header" href="#while-loops" id="while-loops">While loops</a></h4>
<p>To achieve a while loop, use <code>CodeBlock::'whileTrue:'</code> or <code>CodeBlock::'whileFalse:'</code></p>
<pre><code class="language-ruby">var a is 123.
{^a sin &gt; 0.} whileTrue: {
    Pen write: a + ' '.
    a -=: 1.
}.
</code></pre>
<h3><a class="header" href="#breakcontinue" id="breakcontinue">Break/Continue</a></h3>
<p>Simply use <code>Boolean::'break'</code> or <code>Boolean::'continue'</code></p>
<p>Should the given boolean be true, they will break/continue the loop.</p>
<h3><a class="header" href="#iterating-over-collections" id="iterating-over-collections">Iterating over collections</a></h3>
<p>Most if not all collections support these methods (if applicable)</p>
<ul>
<li><code>each:</code> Simply iterates over the container, passing index(key), value, collection</li>
<li><code>each_v:</code> Iterates over the container, but only passes value, collection</li>
<li><code>fmap:</code> Iterates over the container, and replaces the element it has passed with the return value. passes only value</li>
<li><code>imap:</code> Iterates over the container, and replaces the element it has passed with the return value. passes index, value</li>
</ul>
<pre><code class="language-ruby">var arr is Array &lt; 10 ; 20 ; 30 ; 40 ; 50.
arr fmap: {:x ^x + 2.}. # =&gt; Array &lt; 12 ; 22 ; 32 ; 42 ; 52
arr imap: {:i:x ^x + i.}. # =&gt; Array &lt; 10 ; 21 ; 32 ; 43 ; 54
arr each: {:i:x Pen writeln: 'Index $$i = $$x'. }. # =&gt; returns arr, prints a bunch of stuff

var map is Map fromArray: [ ['Test', 'test'], ['KEY', 'key'], [[], 'Whoa'], [1234, []] ].
map fmap: {:value ^value toString reverse.}. # =&gt; (Map new) put:'tseT' at:'Test', put:'YEK' at:'KEY', put:'][' at:([]), put:'4321' at:1234
map each: {:key:value Pen writeln: '$$key = $$value'.}. # =&gt; returns map, prints a bunch of lines
</code></pre>
<h2><a class="header" href="#functions" id="functions">Functions</a></h2>
<p>functions in citron are simply code blocks given name.</p>
<p>to make a function, you may simply assign a code block to a variable:</p>
<pre><code class="language-ruby">var fn is {:x:y
    Pen writeln: (x abs - y).
    ^x pow: y.
}.
</code></pre>
<p>and to call a function, simply send a message to it:</p>
<pre><code class="language-ruby">fn applyTo: 1 and: 2. #apply arguments over several keyword args
fn applyAll: [1, 2]. #apply all arguments at once with a tuple
</code></pre>
<p>If not enough arguments are passed, depending on the message, you might get either an exception, or have the parameter simply evaluate to <code>Nil</code></p>
<p>(<code>CodeBlock::'applyAll:'</code> will throw an exception if more or less arguments are provided)</p>
<p>Functions will behave just like code blocks in every aspect.</p>
<h3><a class="header" href="#the-self-parameter" id="the-self-parameter">The `self' parameter</a></h3>
<p>In order to mitigate the problem with <code>me</code> always referencing the current block, you may simply add <code>self</code> as the first parameter to the block, like so:</p>
<pre><code class="language-ruby">fn is {:self:par
    Pen writeln: par.
    #`self' here is a direct reference to this block
    ^{
        ^const self. #and it still references that block
    }.
}. #self is implicitly filled, acts as if it never existed
fn applyTo: 1024. #par gets assigned 1024
</code></pre>
<h3><a class="header" href="#varargs" id="varargs">Varargs</a></h3>
<p>To collect all extra arguments in an array, you may provide a vararg <code>*argument_name</code> in the formal parameters</p>
<pre><code class="language-ruby">fn is {:x:*ys
    Pen writeln: 'I got some $$x and a bunch of $$ys'.
}.
</code></pre>
<p>Evaluation of different callings:</p>
<pre><code class="language-ctr">⠒⠂fn is {:x:*ys Pen writeln: 'I got some $$x and a bunch of $$ys'.}.
[_:Block]
⠕ fn applyTo: 1.
I got some 1 and a bunch of Array new
[_:Block]
⠕ fn applyTo: 1 and: 2.
I got some 1 and a bunch of Array ← 2
[_:Block]
⠕ fn applyAll: [1,2,3].
I got some 1 and a bunch of Array ← 2 ; 3
[_:Block]
⠕ fn applyAll: [1].
I got some 1 and a bunch of Array new
[_:Block]
</code></pre>
<h3><a class="header" href="#calling-by-reference-vs-calling-by-value" id="calling-by-reference-vs-calling-by-value">Calling by Reference vs Calling by Value</a></h3>
<p>Normally, &quot;simple&quot; objects are passed by value, and the rest are passed by reference;</p>
<p>However, by prepending an ampersand (<code>&amp;</code>) to an argument, it will <em>always</em> be passed as a reference.</p>
<h5><a class="header" href="#note" id="note">Note</a></h5>
<p>Lambdas and Lexical Blocks will <em>not</em> accept reference arguments</p>
<p>Here's a handy table:</p>
<table><thead><tr><th align="left">Type/Behaviour</th><th align="left">Behaviour under <code>:arg</code></th><th align="left">Behaviour under <code>:&amp;arg</code></th><th align="left">Behaviour under <code>:*arg</code></th></tr></thead><tbody>
<tr><td align="left">Nil</td><td align="left">Reference</td><td align="left">Reference</td><td align="left">Reference</td></tr>
<tr><td align="left">String</td><td align="left">Copy</td><td align="left">Reference</td><td align="left">Reference</td></tr>
<tr><td align="left">Boolean</td><td align="left">Copy</td><td align="left">Reference</td><td align="left">Reference</td></tr>
<tr><td align="left">Number</td><td align="left">Copy</td><td align="left">Reference</td><td align="left">Reference</td></tr>
<tr><td align="left">Array</td><td align="left">Reference</td><td align="left">Reference</td><td align="left">Reference</td></tr>
<tr><td align="left">Any other type</td><td align="left">Reference</td><td align="left">Reference</td><td align="left">Reference</td></tr>
</tbody></table>
<h3><a class="header" href="#calling-functions" id="calling-functions">Calling functions</a></h3>
<p>There are several ways to interact with functions, each can be used for some very specific purpose:</p>
<ol>
<li>
<p>Simply using the different messages that <code>CodeBlock</code> provides: <code>applyTo:[and:]*</code> and <code>applyAll:</code></p>
<ul>
<li><code>func applyTo: 1 and: 2</code></li>
<li><code>func applyAll: [1, 2]</code></li>
</ul>
</li>
<li>
<p>Using the call shorthand (<code>expr [...]</code> by default)</p>
<ul>
<li><code>func [1, 2]</code></li>
</ul>
</li>
<li>
<p>using the infix function call (for binary functions)</p>
<ul>
<li><code>1 `func` 2</code></li>
<li>This mode can be configured (with a pragma) to lazily pass the arguments</li>
</ul>
</li>
<li>
<p>using the lazy call shorthand (not configurable) (<code>expr {...}</code>)</p>
<ul>
<li><code>func {1, 2}</code></li>
</ul>
</li>
</ol>
<h3><a class="header" href="#example-outlining-all-the-above-methods" id="example-outlining-all-the-above-methods">Example outlining all the above methods</a></h3>
<pre><code class="language-ruby">⠕ var fun0 is \:x:y x + y
[_:Block]
⠕ fun0 applyTo: 1 and: 2
3
⠕ fun0 applyAll: [1, 2]
3
⠕ fun0 [1, 2]
3
⠕ 1 `fun0` 2
3
# lazy evaluation style =&gt; explicit evaluation
⠕ var fun0 is \:x:y x evaluate + y evaluate
[_:Block]
# a pragma in eval
⠕ :!pragmaOnce::declare lazyev fun0
⠕ 1 `fun0` 2
3
⠕ fun0 {1, 2}
3
⠕ var fun_ref is {:&amp;x:y ^(x +=: 1) + y.}
[_:Block]
⠕ var x is 1
1
⠕ var y is 2
2
⠕ fun_ref[x, y]
4
⠕ x
2
⠕ y
2
</code></pre>
<h2><a class="header" href="#data-structures" id="data-structures">Data Structures</a></h2>
<p>There are three basic builtin <em>native</em> structures in Citron - <em>Array</em>, <em>Tuple</em> and <em>Map</em></p>
<p>which are further extended by non-native extensions - <em>Set</em> and <em>Generator</em></p>
<h3><a class="header" href="#array" id="array">Array</a></h3>
<p><code>Array</code> is basically a list of values, implemented as a contiguous array.</p>
<p>Its' elements can have any type, and it can be created literally by the <code>push:</code> method.</p>
<p><code>Array new push: 3, push: 'test', push: Nil</code></p>
<p>or with a shorthand:</p>
<p><code>Array &lt; 3 ; 'test' ; Nil</code></p>
<h4><a class="header" href="#basic-example" id="basic-example">Basic example</a></h4>
<pre><code class="language-py">var shoplist := Array &lt; 'apple' ; 'mango' ; 'pure chocolate' ; 'old memes'.

Pen writeln: 'There are ' + (shoplist count) + ' items to buy.'.
Pen writeln: 'Those items are: %:L' % [' ', shoplist].

Pen writeln: 'I also want some programming socks!'.

shoplist push: 'programming socks'.

Pen write: 'Now I have to buy all of these shticks:\n'.
shoplist each: {:idx:name
    Pen writeln: '\t$$idx - $$name'.
}.

Pen write: 'Such a bad list, let me sort it first: '.
shoplist is shoplist sort: {:a:b 
    # now compare items a and b
    ^(a length) &gt; (b length). #Whichever has a longer name last
}.
Pen writeln: '%L' % [shoplist].

Pen writeln: 'I have bought this trash now: %s, and I have these left to buy: %L' % [shoplist shift, shoplist].
</code></pre>
<p>Which should give the output</p>
<pre><code>There are 4 items to buy.
Those items are: apple mango pure chocolate old memes
I also want some programming socks!
Now I have to buy all of these shticks:
        0 - apple
        1 - mango
        2 - pure chocolate
        3 - old memes
        4 - programming socks
Such a bad list, let me sort it first: apple, mango, old memes, pure chocolate, programming socks
I have bought this trash now: apple, and I have these left to buy: mango, old memes, pure chocolate, programming socks
</code></pre>
<h3><a class="header" href="#tuple" id="tuple">Tuple</a></h3>
<p>Tuples are - much like other languages that have them - like immutable arrays</p>
<p>Their syntax is quite simple: <code>[ element0, element1 ]</code></p>
<h4><a class="header" href="#basic-example-1" id="basic-example-1">Basic example</a></h4>
<pre><code class="language-ruby">var zoo is ['level-headed lion', 'crazy snek', 'memeified pinguin'].
Pen writeln: 'There are %d animals in this zoo' % [zoo count].

#Any attempt at changing them deegrades them to an Array (or throws an exception)
var zoo1 is ['anime-loving pinguin'] + zoo.
Pen writeln: 'This zoo of %s is a very meme-like zoo, but this %s zoo is not!' % [zoo1, zoo]. #They retain their tuple-ness when printed literally

#as normal, degraded tuples are just arrays
Pen writeln: zoo1 pop.

#But don't even try to pop something off them or such
Pen writeln: zoo pop.
</code></pre>
<h3><a class="header" href="#output" id="output">Output</a></h3>
<pre><code>There are 3 animals in this zoo
This zoo of Array ← 'anime-loving pinguin' ; 'level-headed lion' ; 'crazy snek' ; 'memeified pinguin' is a very meme-like zoo, but this ['level-headed lion', 'crazy snek', 'memeified pinguin'] zoo is not!
memeified pinguin
Uncaught error has occurred.
Cannot change immutable array's structure
#2 pop (test.ctr: 12)
#1 writeln: (test.ctr: 12)
</code></pre>
<h2><a class="header" href="#map" id="map">Map</a></h2>
<p>Maps are implemented as HashMaps, and respect the hash method provided by the object <code>object::'iHash'</code></p>
<p>They do not have any literals associated with them.</p>
<h5><a class="header" href="#example" id="example">Example</a></h5>
<pre><code class="language-ruby">#They can be either constructed with Map::'put:at:'
var map is Map new put: 'World' at: 'Hello', put: 'Fish' at: 'Dead'.
#Or with Map::'cnew:'
var map1 is Map cnew: {
    Hello =&gt; 'World'.
    Dead =&gt; 'Fish'.
}.
#Or with Map::'fromArray:'
var map2 is Map fromArray: [
    ['Hello', 'World'],
    ['Dead', 'Fish']
].
Pen writeln: 'They serialize upon printing by default:\n' + map.

# You can add, modify, or remove assocs
map put: 'Guy' at: 'Dead'.
#That's sad
map deleteAt: 'Dead'.

#They can contain any object that implements iHash
map put: 1 at: 2, put: '1' at: 3, put: map at: 4. #Even themselves

Pen writeln: map.

#They can be iterated over:
map each: {:key:value
    Pen writeln: '%s, %s' % [key, value].
}.

#Or mapped to a map with different values
map2 is map fmap: \:key:value key + ', ' + value.

Pen writeln: map2.
</code></pre>
<h4><a class="header" href="#output-1" id="output-1">Output</a></h4>
<pre><code>They serialize upon printing by default:
(Map new) put:'Fish' at:'Dead', put:'World' at:'Hello'
(Map new) put:':selfReference:' at:4, put:'1' at:3, put:1 at:2, put:'World' at:'Hello'
4, (Map new) put:':selfReference:' at:4, put:'1' at:3, put:1 at:2, put:'World' at:'Hello'
3, 1
2, 1
Hello, World
(Map new) put:'Hello, World' at:'Hello', put:'2, 1' at:2, put:'3, 1' at:3, put:'4, (Map new) put:\':selfReference:\' at:4, put:\'1\' at:3, put:1 at:2, put:\'World\' at:\'Hello\'' at:4
</code></pre>
<h1><a class="header" href="#set" id="set">Set</a></h1>
<p>Sets are implemented basically as Maps, without values (they have a fixed value, which is shared between all sets).</p>
<p>No literals.</p>
<h4><a class="header" href="#example-1" id="example-1">Example</a></h4>
<pre><code class="language-ruby"># HashSet
import Library/Data/Set/HashSet: 'HashSet'.
# or as 'Set':
# import Library/Data/Set/HashSet: { HashSet =&gt; 'Set'. }

var set is HashSet new. # =&gt; {}
set add: 1, add: 2. # =&gt; {2, 1}

# Or maybe if you have a bunch
set addAll: ['test', 3]. # =&gt; {3, 'test', 2, 1}

# Remove an element
set remove: 'test'. # =&gt; {3, 2, 1}

# Check if an element exists
set contains: 'test'. # =&gt; False

# Bloom Filter
import Library/Data/Set/BloomFilter: 'BloomFilter'.

# These sets are neat, they provide a definite not-existence answer only
# That is, you cannot retrieve data from them, nor can you reliably remove data from them
# But they only contain a Number, and can be a fast low-confidence filter

var bf is BloomFilter new.
bf add: 'test', add: 'something else', add: 64. # =&gt; [BloomFilter]

bf contains: 4. # =&gt; False
bf contains: 'test'. # =&gt; True
</code></pre>
<h1><a class="header" href="#generators" id="generators">Generators</a></h1>
<p>Generators are lazy list generators, they have a few helpful basic functionalities as well.</p>
<p><code>Number..Number</code> and <code>Number..Number..Number</code> exists as a literal (see example)</p>
<h3><a class="header" href="#example-2" id="example-2">Example</a></h3>
<pre><code class="language-ruby"># You can make a simple step generator with numbers:
var gen0 is 0..10. # =&gt; [StepGenerator]
# With a step value
var gen1 is 0..2..10. # =&gt; [StepGenerator]

# Or through messages to Generator
var gen2 is Generator from: 0 to: 10.
var gen3 is Generator from: 0 to: 10 step: 2.
var gen4 is Generator repeat: Nil. # This will just make `Nil's forever, it's useful to map
var gen5 is Generator elementsOf: [1,2,3,4]. # Makes a generator from a collection (Array,Map,String)

# You can get the next value
gen0 next. # =&gt; 0
gen0 next. # =&gt; 1

# You can map them to a new generator
var gen6 is gen0 fmap: \:x x + 3.
# Note that advancing one will advance the other too
gen6 next. # =&gt; 5
gen0 next. # =&gt; 3

# You can return a generator from a mapping, and `inext' will expand it
var gen7 is gen4 fmap: \:_ gen0 copy. # make the elements of gen0. forever.

gen7 inext. # =&gt; 4
gen7 inext. # =&gt; 5
(1..10) fmap: \:_ gen7 inext, toArray. # =&gt; Array ← 6 ; 7 ; 8 ; 9 ; 10 ; 6 ; 7 ; 8 ; 9 ; 10

# You can break in the middle of a mapping too, which will terminate the generator
</code></pre>
<h1><a class="header" href="#list-comprehensions" id="list-comprehensions">List Comprehensions</a></h1>
<p>Everyone likes list comprehensions, so here, you can have them too.</p>
<p>Literal: too many to list, take a look at the example</p>
<h4><a class="header" href="#example-3" id="example-3">Example</a></h4>
<pre><code class="language-ruby">var list0 is [x,, 1..10]. # Free variables are bound in order
# =&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# You can specify any number of predicates
list0 is [x,, 1..10,, (x mod: 4, = 0)]. # Only multiples of 4
# =&gt; [4, 8]

list0 is [x,, 1..10,, (x mod: 4, = 0), (x &gt; 4)]. # only multiples of 4 bigger then 4
# =&gt; [8]

# You can do without a source too
var conditionally10 is [10,,, False]. # =&gt; []
# Note the 3 commas

var a is 10.
var list1 is [a + x,, 1..3]. # bound names stay as they are
# =&gt; [13, 14, 15]

# More than one source (Generators not supported  yet)
var list2 is [x + y,, [1,2,3], [5,6,7]]. # =&gt; Array ← 6 ; 7 ; 8 ; 7 ; 8 ; 9 ; 8 ; 9 ; 10
var list3 is [x + y,, [1,2,3], [5,6,7],, x &gt; y]. # =&gt; []

# You can specify the names as well
var list4 is [x + y,, (y: [1,2,3]), (x: [5,6,7]),, x &lt; y, (x mod: y &gt; 2)].

# You can return any citron object
var dispatch is Map fromArray: [[x, {\:arg arg at: x.}],, 1..5]. # returns a 2-tuple of key and a block that calls its argument with that key
# =&gt; (Map new) put:([:Block]) at:5, put:([:Block]) at:4, put:([:Block]) at:3, put:([:Block]) at:2, put:([:Block]) at:1

# Now call it!
dispatch at: 1, applyTo: [1,2,3]. # =&gt; 2
</code></pre>
<h1><a class="header" href="#todo-more-strings" id="todo-more-strings">TODO: more Strings</a></h1>
<h2><a class="header" href="#data-structures-1" id="data-structures-1">Data Structures</a></h2>
<p>There are three basic builtin <em>native</em> structures in Citron - <em>Array</em>, <em>Tuple</em> and <em>Map</em></p>
<p>which are further extended by non-native extensions - <em>Set</em> and <em>Generator</em></p>
<h3><a class="header" href="#array-1" id="array-1">Array</a></h3>
<p><code>Array</code> is basically a list of values, implemented as a contiguous array.</p>
<p>Its' elements can have any type, and it can be created literally by the <code>push:</code> method.</p>
<p><code>Array new push: 3, push: 'test', push: Nil</code></p>
<p>or with a shorthand:</p>
<p><code>Array &lt; 3 ; 'test' ; Nil</code></p>
<h4><a class="header" href="#basic-example-2" id="basic-example-2">Basic example</a></h4>
<pre><code class="language-py">var shoplist := Array &lt; 'apple' ; 'mango' ; 'pure chocolate' ; 'old memes'.

Pen writeln: 'There are ' + (shoplist count) + ' items to buy.'.
Pen writeln: 'Those items are: %:L' % [' ', shoplist].

Pen writeln: 'I also want some programming socks!'.

shoplist push: 'programming socks'.

Pen write: 'Now I have to buy all of these shticks:\n'.
shoplist each: {:idx:name
    Pen writeln: '\t$$idx - $$name'.
}.

Pen write: 'Such a bad list, let me sort it first: '.
shoplist is shoplist sort: {:a:b 
    # now compare items a and b
    ^(a length) &gt; (b length). #Whichever has a longer name last
}.
Pen writeln: '%L' % [shoplist].

Pen writeln: 'I have bought this trash now: %s, and I have these left to buy: %L' % [shoplist shift, shoplist].
</code></pre>
<p>Which should give the output</p>
<pre><code>There are 4 items to buy.
Those items are: apple mango pure chocolate old memes
I also want some programming socks!
Now I have to buy all of these shticks:
        0 - apple
        1 - mango
        2 - pure chocolate
        3 - old memes
        4 - programming socks
Such a bad list, let me sort it first: apple, mango, old memes, pure chocolate, programming socks
I have bought this trash now: apple, and I have these left to buy: mango, old memes, pure chocolate, programming socks
</code></pre>
<h3><a class="header" href="#tuple-1" id="tuple-1">Tuple</a></h3>
<p>Tuples are - much like other languages that have them - like immutable arrays</p>
<p>Their syntax is quite simple: <code>[ element0, element1 ]</code></p>
<h4><a class="header" href="#basic-example-3" id="basic-example-3">Basic example</a></h4>
<pre><code class="language-ruby">var zoo is ['level-headed lion', 'crazy snek', 'memeified pinguin'].
Pen writeln: 'There are %d animals in this zoo' % [zoo count].

#Any attempt at changing them deegrades them to an Array (or throws an exception)
var zoo1 is ['anime-loving pinguin'] + zoo.
Pen writeln: 'This zoo of %s is a very meme-like zoo, but this %s zoo is not!' % [zoo1, zoo]. #They retain their tuple-ness when printed literally

#as normal, degraded tuples are just arrays
Pen writeln: zoo1 pop.

#But don't even try to pop something off them or such
Pen writeln: zoo pop.
</code></pre>
<h3><a class="header" href="#output-2" id="output-2">Output</a></h3>
<pre><code>There are 3 animals in this zoo
This zoo of Array ← 'anime-loving pinguin' ; 'level-headed lion' ; 'crazy snek' ; 'memeified pinguin' is a very meme-like zoo, but this ['level-headed lion', 'crazy snek', 'memeified pinguin'] zoo is not!
memeified pinguin
Uncaught error has occurred.
Cannot change immutable array's structure
#2 pop (test.ctr: 12)
#1 writeln: (test.ctr: 12)
</code></pre>
<h2><a class="header" href="#map-1" id="map-1">Map</a></h2>
<p>Maps are implemented as HashMaps, and respect the hash method provided by the object <code>object::'iHash'</code></p>
<p>They do not have any literals associated with them.</p>
<h5><a class="header" href="#example-4" id="example-4">Example</a></h5>
<pre><code class="language-ruby">#They can be either constructed with Map::'put:at:'
var map is Map new put: 'World' at: 'Hello', put: 'Fish' at: 'Dead'.
#Or with Map::'cnew:'
var map1 is Map cnew: {
    Hello =&gt; 'World'.
    Dead =&gt; 'Fish'.
}.
#Or with Map::'fromArray:'
var map2 is Map fromArray: [
    ['Hello', 'World'],
    ['Dead', 'Fish']
].
Pen writeln: 'They serialize upon printing by default:\n' + map.

# You can add, modify, or remove assocs
map put: 'Guy' at: 'Dead'.
#That's sad
map deleteAt: 'Dead'.

#They can contain any object that implements iHash
map put: 1 at: 2, put: '1' at: 3, put: map at: 4. #Even themselves

Pen writeln: map.

#They can be iterated over:
map each: {:key:value
    Pen writeln: '%s, %s' % [key, value].
}.

#Or mapped to a map with different values
map2 is map fmap: \:key:value key + ', ' + value.

Pen writeln: map2.
</code></pre>
<h4><a class="header" href="#output-3" id="output-3">Output</a></h4>
<pre><code>They serialize upon printing by default:
(Map new) put:'Fish' at:'Dead', put:'World' at:'Hello'
(Map new) put:':selfReference:' at:4, put:'1' at:3, put:1 at:2, put:'World' at:'Hello'
4, (Map new) put:':selfReference:' at:4, put:'1' at:3, put:1 at:2, put:'World' at:'Hello'
3, 1
2, 1
Hello, World
(Map new) put:'Hello, World' at:'Hello', put:'2, 1' at:2, put:'3, 1' at:3, put:'4, (Map new) put:\':selfReference:\' at:4, put:\'1\' at:3, put:1 at:2, put:\'World\' at:\'Hello\'' at:4
</code></pre>
<h1><a class="header" href="#set-1" id="set-1">Set</a></h1>
<p>Sets are implemented basically as Maps, without values (they have a fixed value, which is shared between all sets).</p>
<p>No literals.</p>
<h4><a class="header" href="#example-5" id="example-5">Example</a></h4>
<pre><code class="language-ruby"># HashSet
import Library/Data/Set/HashSet: 'HashSet'.
# or as 'Set':
# import Library/Data/Set/HashSet: { HashSet =&gt; 'Set'. }

var set is HashSet new. # =&gt; {}
set add: 1, add: 2. # =&gt; {2, 1}

# Or maybe if you have a bunch
set addAll: ['test', 3]. # =&gt; {3, 'test', 2, 1}

# Remove an element
set remove: 'test'. # =&gt; {3, 2, 1}

# Check if an element exists
set contains: 'test'. # =&gt; False

# Bloom Filter
import Library/Data/Set/BloomFilter: 'BloomFilter'.

# These sets are neat, they provide a definite not-existence answer only
# That is, you cannot retrieve data from them, nor can you reliably remove data from them
# But they only contain a Number, and can be a fast low-confidence filter

var bf is BloomFilter new.
bf add: 'test', add: 'something else', add: 64. # =&gt; [BloomFilter]

bf contains: 4. # =&gt; False
bf contains: 'test'. # =&gt; True
</code></pre>
<h1><a class="header" href="#generators-1" id="generators-1">Generators</a></h1>
<p>Generators are lazy list generators, they have a few helpful basic functionalities as well.</p>
<p><code>Number..Number</code> and <code>Number..Number..Number</code> exists as a literal (see example)</p>
<h3><a class="header" href="#example-6" id="example-6">Example</a></h3>
<pre><code class="language-ruby"># You can make a simple step generator with numbers:
var gen0 is 0..10. # =&gt; [StepGenerator]
# With a step value
var gen1 is 0..2..10. # =&gt; [StepGenerator]

# Or through messages to Generator
var gen2 is Generator from: 0 to: 10.
var gen3 is Generator from: 0 to: 10 step: 2.
var gen4 is Generator repeat: Nil. # This will just make `Nil's forever, it's useful to map
var gen5 is Generator elementsOf: [1,2,3,4]. # Makes a generator from a collection (Array,Map,String)

# You can get the next value
gen0 next. # =&gt; 0
gen0 next. # =&gt; 1

# You can map them to a new generator
var gen6 is gen0 fmap: \:x x + 3.
# Note that advancing one will advance the other too
gen6 next. # =&gt; 5
gen0 next. # =&gt; 3

# You can return a generator from a mapping, and `inext' will expand it
var gen7 is gen4 fmap: \:_ gen0 copy. # make the elements of gen0. forever.

gen7 inext. # =&gt; 4
gen7 inext. # =&gt; 5
(1..10) fmap: \:_ gen7 inext, toArray. # =&gt; Array ← 6 ; 7 ; 8 ; 9 ; 10 ; 6 ; 7 ; 8 ; 9 ; 10

# You can break in the middle of a mapping too, which will terminate the generator
</code></pre>
<h1><a class="header" href="#list-comprehensions-1" id="list-comprehensions-1">List Comprehensions</a></h1>
<p>Everyone likes list comprehensions, so here, you can have them too.</p>
<p>Literal: too many to list, take a look at the example</p>
<h4><a class="header" href="#example-7" id="example-7">Example</a></h4>
<pre><code class="language-ruby">var list0 is [x,, 1..10]. # Free variables are bound in order
# =&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# You can specify any number of predicates
list0 is [x,, 1..10,, (x mod: 4, = 0)]. # Only multiples of 4
# =&gt; [4, 8]

list0 is [x,, 1..10,, (x mod: 4, = 0), (x &gt; 4)]. # only multiples of 4 bigger then 4
# =&gt; [8]

# You can do without a source too
var conditionally10 is [10,,, False]. # =&gt; []
# Note the 3 commas

var a is 10.
var list1 is [a + x,, 1..3]. # bound names stay as they are
# =&gt; [11, 12, 13]

# More than one source
var list2 is [x + y,, [1,2,3], [5,6,7]]. # =&gt; Array ← 6 ; 7 ; 8 ; 7 ; 8 ; 9 ; 8 ; 9 ; 10
var list3 is [x + y,, [1,2,3], [5,6,7],, x &gt; y]. # =&gt; []
var list4 is [x + y,, 1..3, 5..7]. # =&gt; Array ← 6 ; 7 ; 8 ; 7 ; 8 ; 9 ; 8 ; 9 ; 10

# You can specify the names as well
var list5 is [x + y,, (y: [1,2,3]), (x: [5,6,7]),, y &lt; x, (x mod: y, &lt; 1)]. # =&gt; Array ← 6 ; 7 ; 8 ; 8 ; 9
var list6 is [x + y,, (x: 1..3), (y: 5..7),, y - x &lt; 5] # =&gt; Array ← 6 ; 7 ; 8 ; 8 ; 9 ; 10

# You can return any citron object
var dispatch is Map fromArray: [[x, {\:arg arg at: x.}],, 1..5]. # returns a 2-tuple of key and a block that calls its argument with that key
# =&gt; (Map new) put:([:Block]) at:5, put:([:Block]) at:4, put:([:Block]) at:3, put:([:Block]) at:2, put:([:Block]) at:1

# Now call it!
dispatch at: 1, applyTo: [1,2,3]. # =&gt; 2
</code></pre>
<h1><a class="header" href="#todo-more-strings-1" id="todo-more-strings-1">TODO: more Strings</a></h1>
<p><a href="intermission-interpreter-commands.html">&lt;- Prev</a> <a href="objects.html">Next -&gt;</a></p>
<h2><a class="header" href="#objects" id="objects">Objects</a></h2>
<p>Objects are the main attraction in Citron (but are in no way forced)</p>
<p>You may instantiate any object by the default <code>Object::'new'</code> method (all objects should treat this method as a request for a new instance)</p>
<p>or directly execute code in the newly created object instance by using <code>Object::'cnew:'</code></p>
<p>Objects can interface each other <em>only</em> by their methods (no way to access object fields directly if said object does not expose a method for it)</p>
<p>In each object's context o execution, an implicit <code>me</code> reference refers to the object itself, and the object's properties are accessible by <code>my</code> qualified references.</p>
<h4><a class="header" href="#dumb-example" id="dumb-example">Dumb example</a></h4>
<pre><code class="language-ruby">var Person is Object cnew: { name =&gt; 'Dummy'. }.
#To add a method, use Object::'on:do:'
Person on: 'new:' do: {:name ^me cnew: { name =&gt; name. }. }.
Person on: 'name' do: { ^my name. }, #You are most welcome to chain these should you wish to
 on: 'greet:' do: {:other
    #just assume other responds to 'name'
    Pen writeln: 'Hello, ' + other name + ', I am ' + my name.
}. #All such methods implicitly return `me' if nothing is explicitly returned.

var p0 is Person new: 'Idiot'.
var p1 is Person new: 'Fool'.

p0 greet: p1. #p1 supports ::'name'
#let's try with something that doesn't
p1 greet: 'Semicolon'.
</code></pre>
<h5><a class="header" href="#dumb-output" id="dumb-output">Dumb output</a></h5>
<pre><code>Hello, Fool, I am Idiot
Uncaught error has occurred.
Unknown method String::'name' was called
#4 name (test.ctr: 7)
#3 + (test.ctr: 7)
#2 writeln: (test.ctr: 7)
#1 greet: (test.ctr: 15)
</code></pre>
<h3><a class="header" href="#inheritance" id="inheritance">Inheritance</a></h3>
<p>The usual single-inheritance rules apply (only to methods, and calling the parent constructor should be <em>explicit</em>)</p>
<pre><code class="language-ruby">var P is Object new on: 'method' do: { ^'Parent method'. }.
var C is P new.
#Overrides have no special syntax
C on: 'method' do: { ^'Child method'. }.
Pen writeln: C method. #=&gt; 'Child method'
</code></pre>
<p>Multiple inheritance <em>is</em> supported, in a way.</p>
<p>You may 'inherit' from other objects and delegate method calls to their defintiions:</p>
<pre><code class="language-ruby">var P0 is Object new on: 'test0' do: {^'test0'.}.
var P1 is Object new on: 'test1' do: {^'test1'.}.
var C is P0 new inheritFrom: P1.

#Now ::'test1' will properly work (it will not contain any references to P1)
C test1. #=&gt; 'test1'
</code></pre>
<h2><a class="header" href="#io" id="io">IO</a></h2>
<p>Everyone adores I/O, well, not everyone, that poor processor that is always kept waiting sure doesn't.</p>
<p>The basic input methods are available with the <code>Program::'input'</code>, <code>Program::'waitForInput'</code> and <code>Program::'getCharacter'</code> (only available with termios)</p>
<p>the more...sophisticated actions can be performed with <code>stdin</code> : <code>File special: 'sdin'</code> will give an auto-cleaning handle to it.</p>
<h3><a class="header" href="#input" id="input">Input</a></h3>
<pre><code class="language-ruby">var thing is Program waitForInput.
Pen writeln: 'in reverse: ' + thing reverse.
Pen writeln: 'SPACEY: ' + (thing characters join: ' ').
#This will raise an exception if any extra character remains after conversion
Pen writeln: 'Trying to make a number of it: ' + (thing toNumber).
</code></pre>
<p>Output for <code>123test</code>:</p>
<pre><code>123test
in reverse:
tset321
SPACEY: 1 2 3 t e s t

Uncaught error has occurred.
cannot build number, extranous characters in string
#3 toNumber (test.ctr: 5)
#2 + (test.ctr: 5)
#1 writeln: (test.ctr: 5)
</code></pre>
<h4><a class="header" href="#palindromes-because-every-language-needs-one" id="palindromes-because-every-language-needs-one">Palindromes, because every language needs one</a></h4>
<pre><code class="language-ruby">var is_palindrome is {:str
    ^str reverse = str.
}.
{^True.} whileTrue: {
    Pen write: 'What be your text? '.
    Pen writeln: (is_palindrome applyTo: Program waitForInput trim, either: 'Yep, that\'s a palindrome' or: 'Nope, not a plaindrome').
}.
</code></pre>
<p>Profoundly, the output:</p>
<pre><code>What be your text? str
Nope, not a plaindrome
What be your text? 1001
Yep, that's a palindrome
What be your text? []
Nope, not a plaindrome
^C
</code></pre>
<h3><a class="header" href="#files" id="files">Files</a></h3>
<p>Files are fun things, they respond to <code>read</code>, <code>readBytes:</code>, <code>write:</code> and more!</p>
<h5><a class="header" href="#opening-a-file" id="opening-a-file">Opening a file</a></h5>
<p>You may implicitly open a file for reading or writing depending on the operation (no need to state <code>open:</code>)</p>
<pre><code class="language-ruby">#You may write to it normally
File new: 'test', write: 'This is a test\n' * 100.
#Or open it explicitly
File new: 'test', open: 'w+', write: 'This be a test\n', close. #Resources are cleaned by the garbage collector, but explicitly closing it is preferred
</code></pre>
<h4><a class="header" href="#special-purpose-files" id="special-purpose-files">Special-purpose Files</a></h4>
<p>there are three special file descriptors <code>stdin</code> <code>stdout</code> and <code>stderr</code></p>
<p>You may access these by <code>File::'special:'</code></p>
<p>Note that <code>stdin</code> does <em>not</em> allow writes, and the other two do not allow reads.</p>
<h2><a class="header" href="#exceptions" id="exceptions">Exceptions</a></h2>
<p>Exceptions in Citron are pretty much the same as all other languages; they occur when <em>exceptional</em> things occur!</p>
<h3><a class="header" href="#basic-errors" id="basic-errors">Basic Errors</a></h3>
<p>Errors can be generated with <code>Block::'error:'</code></p>
<p>The interpreter itself also can generate errors for unkown keys, etc.</p>
<pre><code class="language-ruby">⠕ Pen writenl: 'This will make an exception!'. #Note that the method name is spelled incorrectly
#=&gt; Exception: Unknown method Object::'writenl:' was called
⠕ pen writeln: 'This will do that too'. #Misspelled 'Pen'
#=&gt; Exception: Key not found: pen
</code></pre>
<h3><a class="header" href="#raising-and-handling-exceptions" id="raising-and-handling-exceptions">Raising and Handling Exceptions</a></h3>
<p>All the exceptions generated by the interpreter are of type String, however a facility is provided to use and catch exceptions of different types:</p>
<pre><code class="language-ruby">{
    thisBlock error: Nil.
} catch: {:e Pen writeln: 'Nil!'.} type: Nil,
  run.

#=&gt; Nil!
</code></pre>
<p>There is not much more involved, just note that exceptions are used only when no other way of handling the current situation exists.</p>
<p>For instance, a miss on a map lookup is not an exceptional thing, it will simply return Nil.</p>
<h2><a class="header" href="#library--imports" id="library--imports">Library / Imports</a></h2>
<h3><a class="header" href="#the-import-object" id="the-import-object">The import Object</a></h3>
<p>Citron's answer to handling modular programs, is of course, the <code>import</code> Object.</p>
<p>Yes, you read that right; Object.</p>
<p>The basic import syntax is like so:</p>
<p><code>import path/to/module/directory</code></p>
<p>you may also directly import ctr files the same way:</p>
<p><code>import path/to/file</code></p>
<p>There are a few rules to the import mechanism:</p>
<ul>
<li>If a diretory is provided, there <em>must</em> be a <code>main.ctr</code> file inside that directory</li>
<li>If the path to a file is provided, it <em>must</em> have a .ctr extension</li>
<li>If a file is outside the search paths, it may be imported using absolute paths</li>
<li>Only the directly exported names inside the module are imported, unless explicitly requested (more on this later)</li>
<li>imported object will be added to the global scope of the program</li>
</ul>
<p>You can change the name of the explicit imports by assigning them in a block (see example below)</p>
<h3><a class="header" href="#importing-something-from-the-standard-library" id="importing-something-from-the-standard-library">Importing something from the standard library</a></h3>
<p>The standard library is not very extensive, but it does have most of the essentials.</p>
<p>Example:</p>
<pre><code class="language-ruby">import Library/Data/Set/HashSet: 'HashSet'. # Will only import the object HashSet
import Library/Data/Set/HashSet: { HashSet =&gt; 'Set'. }. # Will only import the object HashSet, as `Set'
import Library/Data/Map. # Will import all the exported values in that module
import Library/Functional/PatternMatch: \*. # Will import all the values in that module
</code></pre>
<h3><a class="header" href="#importing-specific-names-from-a-module" id="importing-specific-names-from-a-module">Importing specific names from a module</a></h3>
<p>The <code>import</code> object will try to import any name given to it in the following ways:</p>
<ol>
<li>
<p>Import only the exported names: <code>import path/to/module</code></p>
</li>
<li>
<p>Import one specific name from the module, in addition to the exports: <code>import path/to/module: 'whatever'</code></p>
</li>
<li>
<p>Import a list of names from some module: <code>import path/to/module: &lt;Array of string&gt;</code></p>
</li>
<li>
<p>Import a few names, specifying new names: <code>import path/to/module: { oldName =&gt; 'newName'. oldName2 =&gt; 'newName2'. }</code></p>
</li>
<li>
<p>Import all the symbols in a module: <code>import path/to/module: \*</code></p>
<ul>
<li><code>*</code> is a Symbol, it is a kind of String that is allocated only once.</li>
</ul>
</li>
</ol>
<h2><a class="header" href="#the-standard-library" id="the-standard-library">The standard library</a></h2>
<p>The library is still a work in progress, but it should have the basic needs, and facilities to interface C APIs for less common needs.</p>
<p>The layout of the library closely resembles Haskell's, with the library being split into several categories.</p>
<p>The current categories (as of Citron 0.0.8) are:</p>
<ul>
<li>AST : contains simple interfaces to change or view the AST of a program</li>
<li>Control : contains various modules to handle or change the program control flow</li>
<li>Data : contains modules for data structures</li>
<li>Executable : executable modules, which can be run with <code>citron -m &lt;name&gt;</code></li>
<li>Extensions : loads the old extensions (deprecated)</li>
<li>Foreign : contains modules that handle the foreign functions interfacing</li>
<li>Functional : contains modules that allow for a more functional style of coding</li>
<li>Graphics : graphical things</li>
<li>GUI : modules for creation and handling of user interfaces</li>
<li>Net : modules that handle sockets and networks</li>
<li>Utils : various utilities</li>
</ul>
<h3><a class="header" href="#the-control-category" id="the-control-category">The Control category</a></h3>
<ul>
<li>Applicative : Adds several method to CodeBlock for convenience, for instance <code>apply:</code> and <code>compose:</code></li>
<li>Arrow : Adds an arrow method to Object to resolve methods and properties</li>
<li>Class : WIP module that adds classification (To be replaced by Categorization)</li>
<li>Error : Several Basic error types, implemented for your convenience</li>
<li>Method : An object that generates generic message sender methods</li>
<li>MethodResolve : A way to extract methods (raw, or with refs) from objects, and use them as code blocks</li>
</ul>
<h3><a class="header" href="#the-data-category" id="the-data-category">The Data category</a></h3>
<ul>
<li>Array : mostly deprecated stuff. subject to removal</li>
<li>IO : /StringIO -&gt; Fake strings as files.</li>
<li>Iterator : Deprecated. Use <code>Generator</code> instead</li>
<li>List : Implementation of LinkedLists (for whatever reason)</li>
<li>Map : simplify your use of Maps</li>
<li>Range : Non-lazy list generators</li>
<li>Ratio : Fractions as ratios</li>
<li>Set</li>
<li>
<ul>
<li>/HashSet : Implementation of HashSets</li>
<li>/BloomFilter : Implementation of BloomFilters </li>
</ul>
</li>
<li>String : Nothing.</li>
<li>SwitchCase : Generate a map of alternatives and execute one of them.</li>
</ul>
<h3><a class="header" href="#the-functional-category" id="the-functional-category">The Functional category</a></h3>
<ul>
<li>Alias : common functions for common messages (e.g. <code>+</code> as a polymorphic function)</li>
<li>Applicative</li>
<li>
<ul>
<li>/Maybe -&gt; The Maybe monad as an applicative</li>
</ul>
</li>
<li>Category</li>
<li>
<ul>
<li>Array -&gt; Arrays as composable objects</li>
<li>Block -&gt; Functions as composable objects</li>
</ul>
</li>
<li>Monad : semi context-aware entities that wrap a state</li>
<li>TypeClass : The definition of all the above things, and a few common functions</li>
<li>PatternMatch : Adds a Object::'match:', and a helper <code>match</code> function</li>
<li>
<ul>
<li>More of this in its own page</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#the-executable-category" id="the-executable-category">The Executable category</a></h3>
<ul>
<li>cpm : A package manager. read its help with <code>citron -m cpm</code></li>
</ul>
<h3><a class="header" href="#the-foreignc-category" id="the-foreignc-category">The Foreign/C category</a></h3>
<p>This category is dedicated to interfacing foreign functions, and has a complementary plugin (libctrctypes.so)</p>
<ul>
<li>Alloc : Allocate raw memory with specific sizes</li>
<li>C_Types : common import with names for common C types</li>
<li>errno : module to handle C errno</li>
<li>NamedStruct : Structs with named members</li>
<li>PackedArray : Contiguous Array with uniform native types</li>
<li>Signal : Handle or trade signals with other programs</li>
</ul>
<p>TODO: Finish this page</p>
<h2><a class="header" href="#meta-functions" id="meta-functions">Meta Functions</a></h2>
<p>If you've survived this far, congrats; the ride is going to get even crazier from here.</p>
<p>Meta functions, Basically, allow a function to modify the internal representation of an expression, and optionally return a replacement for it.</p>
<p>They are in a way modeled and built to remedy the need for macros, but ended up quite a bit more powerful (as they are somewhat context aware)</p>
<p>Their definition is absolutely the same as every other function, except they do...meta things.</p>
<p>The basic building blocks are the several compiler intrinsics listed below:</p>
<ol>
<li><code>$(expr)</code></li>
<li><code>$!(expr)</code></li>
<li><code>$[expr, expr, ...]</code></li>
<li><code>$'(expr)</code> or <code>$'expr</code></li>
<li><code>$`(expr)</code> or <code>$`expr</code></li>
</ol>
<p>A brief explanation of their behaviour is as follows:</p>
<ol>
<li>is replaced by the internal (AST) representation of the expression</li>
<li>splices the meta-expression back into the code; it is the reverse action of 1 </li>
<li>is replaced by a tuple containing the AST representation of the contained expressions</li>
<li>quotes an expression (bare references are converted to symbols)</li>
<li>escapes a quoted expression and embeds a value into it</li>
</ol>
<h4><a class="header" href="#a-simple-example" id="a-simple-example">A simple example</a></h4>
<pre><code class="language-ruby">var if-then-else is {:ast 
    ^$!(ast head) either: { #if the first expression evaluates to a truthy value
        ^$!(ast at: 1). #evaluate the second expression
    } or: {
        ^$!(ast at: 2). #otherwise, evaluate the third expression
    }.
}.
var a is Nil.

if-then-else applyTo: 
    $[ # To get a tuple of expressions
        1 = 2, # the condition
        a is 'No Way!', # the if-true branch
        a is 'That\'s right'. # the if-false branch
    ].
# This whole expression will evaluate to the result of &quot;a is 'That\'s right'&quot;, which is the string
</code></pre>
<p>Of course, this feels clunky, and looks weird, but there are more ways to deal with metafunctions, in a more elegant way.</p>
<p>(First, see <a href="/parser-pragmas.html" title="read this first, pleeeeeeeeeease">Parser Pragmas</a>\)</p>
<p>Through the use of the <code>declare</code> pragma, it is possible to create a function that does not evaluate its arguments before being invoked, but rather explicitly after.</p>
<h3><a class="header" href="#example-8" id="example-8">Example:</a></h3>
<pre><code class="language-ruby">#:declare lazyev then

# These sorts of functions are always binary
var letIn is {\:_x:_y
    $!(_x). # Evaluate the first argument, and discard its value
    $!(_y). # Evaluate the second argument, and return its value
}.

(var a is 123) `letIn` (a + 64). # =&gt; 187
# which is equivalent to the following expression
letIn applyAll: [$(var a is 123), $(a + 64)]. # =&gt; 187

#:declare lazyev if-then

# let's write if-then in a more elegant format
var if-then is {\:if:then
    $!(if) ifTrue: {
        ^$!(then).
    }.
}.

var x is 123.

(x = 123) `if-then` (Pen writeln: 'x really is $$x'). # be careful not to shadow `x' in the if-then definition
# -&gt; x really is 123
</code></pre>
<p>Let's take a look at how PatternMatch's <code>match</code> function works</p>
<pre><code class="language-ruby">{:self:ast

var done is True.
var ret is Nil.
var cblk is thisBlock.
ast each_v: {:__PMATCH_V0 # For each sub-tuple in the main tuple
  __PMATCH_V0 is $!(__PMATCH_V0). #Parse the tuple
  done is True.
  ret is {
    self unpack: $!(__PMATCH_V0 head). # Try to unpack the object
    $!(__PMATCH_V0 tail init) all: {\:__PMATCH_V1 # Then assuming the unpacking worked, check all the guards (if any)
      Reflect runHere: {^$!(__PMATCH_V1).} forObject: self arguments: [].
    }, ifFalse: {
      cblk error: 'guard fail'. # If the guard returned false, let this pmatch fail
    }.
    ^Reflect runHere: {^$!(__PMATCH_V0 last).} forObject: self arguments: []. # Assuming everything went well, run the last expression
  } catch: {:e done is False. }, run. # if anything failed, move on through the tuple
  done break. # otherwise, stop
}.
done ifFalse: { cblk error: 'non-exhaustive pattern match'. }. # if after going through the whole list, we didn't find a suitable match, raise an exception
^ret. # return the value

}.
</code></pre>
<h2><a class="header" href="#comptime---when-you-definitely-want-it-to-be-evaluated-at-comptime" id="comptime---when-you-definitely-want-it-to-be-evaluated-at-comptime"><code>@comptime</code> - when you definitely want it to be evaluated at comptime</a></h2>
<p>meta functions are nice and all, but there are times that you want to be <em>sure</em> on the code being evaluated at comptime</p>
<p>a (perhaps deprived) example:</p>
<pre><code class="language-ruby">20 times: {:i
    Pen writeln: i factorial.
}.
</code></pre>
<p>You definitely don't want this sort of code if you can avoid it.</p>
<p>what you can do here is to create a lookup table:</p>
<pre><code class="language-ruby"># make a lookup table
@comptime[discard] # the actual value of this doesn't matter
var lookup-factorial is
    $($`(Array new: 20, fill: 20 with: \:x x factorial)).

20 times: {:i
    Pen writeln: (@comptime lookup-factorial) @ i.
}.
</code></pre>
<p>Now all that happens at runtime is a simple array lookup. although this will break should <code>i</code> be out of the bounds.</p>
<pre><code>1
1
2
6
24
120
720
5040
40320
362880
3628800
39916800
479001600
6227020800
87178291200
1307674368000
20922789888000
355687428096000
6402373705728000
121645100408832000
</code></pre>
<h2><a class="header" href="#parser-pragmas" id="parser-pragmas">Parser Pragmas</a></h2>
<p>The parser supports pragmas in the form of <code>#:pragma_name arguments</code> that modify its behaviour, and these are completely irrelevant to the actual control flow of the program.</p>
<h3><a class="header" href="#basic-pragmas" id="basic-pragmas">Basic Pragmas</a></h3>
<ul>
<li><code>#:oneLineExpressions</code>
<ul>
<li>Promise to be a good child, and end your expressions in one line, and the parser will place the ending dots for you</li>
</ul>
</li>
<li><code>#:regexLineCheck</code>
<ul>
<li>will force the use of regular expressions for newline detection (deprecated, really)</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#not-so-basic-pragmas" id="not-so-basic-pragmas">Not-so-basic Pragmas</a></h3>
<ul>
<li>
<p><code>#:callShorthand LEFT RIGHT</code></p>
<ul>
<li>Will replace the call shorthand <code>expr[]</code> with <code>expr LEFT RIGHT</code></li>
<li>the only accepted tokens are any mix of <code>{</code> <code>[</code> <code>(</code> <code>)</code> <code>]</code> <code>}</code></li>
</ul>
</li>
<li>
<p><code>#:declare &lt;infixl|infixr|lazyev&gt; [prec] &lt;reference&gt;</code></p>
<ul>
<li>Declares the fixity or laziness of a reference (only used when it is invoked through <code>A `ref` B</code></li>
</ul>
</li>
<li>
<p><code>#:language &lt;comma-separated list of extensions&gt;</code><br />
The currently valid extensions are:</p>
<ul>
<li><code>XFrozen</code>
<ul>
<li>Adds a variable modifier <code>frozen</code>, which causes the LHS of an assignment to be evaluated <em>only once</em>. it is only valid in assignments.</li>
</ul>
</li>
<li><code>XPureLambda</code>
<ul>
<li>Memoizes lambda expressions that are detected to be pure (side-effect free)</li>
</ul>
</li>
<li><code>XNakedAsmBlocks</code>
<ul>
<li>Allows insertion of assembly code inside a block specially denoted such [more on this in <a href="parser-pragmas.html#inline-assembly-blocks.md">Inline Assembly Blocks</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#scratchpad" id="scratchpad">Scratchpad</a></h2>
<p>The citron evaluator also ships with a neat little scratchpad, you can launch it like so:</p>
<pre><code class="language-sh">$ citron -m scratchpad
</code></pre>
<p>Its basic functionality is to provide a neat GUI for executing and inspecting citron code.</p>
<p>Unlike the evaluator, it is made to allow editing and executing several lines of code (autocomplete coming soon™)</p>
<h3><a class="header" href="#basic-usage" id="basic-usage">Basic usage</a></h3>
<p>You simply type in some code (it even has live syntax highlighting!) and to execute a (selected) chunk of code, you press F5.</p>
<p>And the resulting value is inserted in the next line.</p>
<h3><a class="header" href="#object-inspection" id="object-inspection">Object inspection</a></h3>
<p>The scratchpad allows you to inspect an object's values and methods (read only, no modification)</p>
<p>To do so, simply send an <code>inspect</code> message to any object:</p>
<pre><code class="language-ruby">Scratchpad inspect
</code></pre>
<p>and a new window with the properties and methods of that object will pop up</p>
<p>The treeview on the left first lists the inheritance chain of the object (if any), then a bunch of '----'s, and then the properties.</p>
<p>Double clicking a property will show its value in the textview on the bottom, and middle-mouse-clicking on a property will <code>inspect</code> it.</p>
<p>The method list on the right is only browsable at the moment.</p>
<h2><a class="header" href="#inline-assembly-blocks" id="inline-assembly-blocks">Inline assembly blocks</a></h2>
<p>Just as every other decent high-level language (not), Citron supports inline assembly blocks (and it can treat them as pretty much normal blocks)</p>
<p>To use this feature, you must enable the <code>XNakedAsmBlock</code> parser pragma.</p>
<p>Then, the syntax is as follows:</p>
<pre><code class="language-ctr">'{' 'asm' [dialect] {argument-types-or-names} (register-constraints) {assembly code} '}'
</code></pre>
<p>Where <code>dialect</code> can be any of <code>intel</code>, <code>att</code>, <code>at&amp;t</code>, or nothing at all (defaults to at&amp;t);</p>
<p>The argument types are typical citron arguments where the name optionally denotes the type (in such cases where the name is not recognised, the type is assumed to be <code>double</code>)</p>
<p>Recognised argument types:</p>
<ul>
<li><code>int</code>: a normal 64 bit integer</li>
<li><code>dbl</code>: a double precision real value</li>
<li><code>str</code>: a pointer to an array of characters</li>
</ul>
<p>the return type is <em>always</em> a 64bit integer (or whatever the default size of the native output register is)</p>
<p>The register constraints are modelled exactly after LLVM's inline assembly expressions, so it is worth reading up on their documentation; however, here is the gist:</p>
<ul>
<li>constraints are separated with commas</li>
<li>Each is a code describing one output, input, or clobbered register
<ul>
<li>output codes start with <code>=</code>
<ul>
<li>They can optionally be prefixed with <code>&amp;</code> to be marked early clobbered</li>
</ul>
</li>
<li>input codes have no prefix</li>
<li>clobber codes start with <code>~</code></li>
</ul>
</li>
<li>The code itself is any one of the following formats
<ul>
<li>one constraint character
<ul>
<li>The most common are <code>r</code> (register) and <code>m</code> (memory)</li>
</ul>
</li>
<li>'{' register-name '}'
<ul>
<li>example: <code>{rax}</code></li>
</ul>
</li>
<li>constraint constraint
<ul>
<li>to allow for alternatives</li>
<li>example: <code>{rax}m</code>: either allocate <code>%rax</code>, or fallback to memory</li>
</ul>
</li>
<li>There must be exactly as many input constraints as there are arguments; any deviation will simply cause either a segfault or a comptime error</li>
</ul>
</li>
</ul>
<p>The assembly code can then refer to the constrainted registers/memory locs by their index in the constraint list: <code>$&lt;index&gt;</code> </p>
<p>For example, if the constraint list is <code>(={rax},m,r)</code>, to address the first input (the memory), <code>$1</code> can be used.</p>
<p>Note that because of this templating system, number literals in at&amp;t syntax must be prefixed with two <code>$</code>, not one (<code>$$0x10</code>)</p>
<h3><a class="header" href="#example-9" id="example-9">Example</a></h3>
<pre><code class="language-ctr">#:language XNakedAsmBlock

var native-fn is {asm intel :int (={rax},r)
    add $1, $1 # double the input
    mov $0, $1 # put it in the output
}.

# Now you can treat `native-fn' as any boring old code block
native-fn applyTo: 4. # =&gt; 8
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
